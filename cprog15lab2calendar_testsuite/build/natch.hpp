/* GENERATED BY NatchBuilder.pm, see repo for original source */

#ifndef NATCH_ENVIRONMENT_DUMMY_VARIABLE_HPP
#define NATCH_ENVIRONMENT_DUMMY_VARIABLE_HPP

#include <functional>

namespace natch {
  namespace details {
    struct dummy_variable { };
  }
}

namespace std {
  template<>
  struct hash<natch::details::dummy_variable> {
    constexpr std::size_t operator() (natch::details::dummy_variable const&) const {
      return 0;
    }
  };
}

#endif
#ifndef NATCH_EXCEPT_HPP
#define NATCH_EXCEPT_HPP

#include <stdexcept>

namespace natch {
  struct fatal_error : std::logic_error { using std::logic_error::logic_error; };
  struct logic_error : std::logic_error { using std::logic_error::logic_error; };
  struct test_error  : std::logic_error { using std::logic_error::logic_error; };
  struct fake_error  :       test_error { using       test_error::test_error;  };
}

#endif
#ifndef NATCH_HELPER_TRAITS_HPP
#define NATCH_HELPER_TRAITS_HPP

#include <type_traits>
  
namespace natch {
// -----------------------------------------------------------------------------

template<class T>
struct identity {
  typedef T type;
};

template<class T>
using identity_t = typename identity<T>::type;
  
// -----------------------------------------------------------------------------

template<class... Ts>
struct type_list {
  static constexpr int size = sizeof... (Ts); 
};

// -----------------------------------------------------------------------------

template<unsigned int N, class T>
struct type_list_element;

template<unsigned int N>
struct type_list_element<N, type_list<>> {};

template<unsigned int N, class T, class... Ts>
struct type_list_element<N, type_list<T, Ts...>> {
  typedef typename std::conditional<N == 0,
    identity<T>,
    type_list_element<N-1, type_list<Ts...>>
  >::type::type type;
};

// -----------------------------------------------------------------------------

template<unsigned int...>
struct integer_sequence { };

template<int N, int... Ns>
struct make_integer_sequence
  : make_integer_sequence<N-1, N-1, Ns...>
{ };

template<int... Ns>
struct make_integer_sequence<-1, -1, Ns...> {
  typedef integer_sequence<Ns...> type;
};

// -----------------------------------------------------------------------------

template<class T>
struct function_info : function_info<decltype (&T::operator())>
{ };

template<class R, class... Args>
struct function_info<R(Args...)> {
  typedef R                  return_type;
  typedef void               object_type;
  typedef type_list<Args...> argument_type_list;
  typedef type_list<typename std::decay<Args>::type...> decayed_argument_list;
};

template<class R, class... Args>
struct function_info<R(*)(Args...)>
  : function_info<R(Args...)>
{ };

template<class R, class T, class... Args>
struct function_info<R(T::*)(Args...)>
  : function_info<R(Args...)>
{
  typedef T object_type;
};

template<class R, class T, class... Args>
struct function_info<R(T::*)(Args...) const>
  : function_info<R(T::*)(Args...)>
{ };

// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------

template<class T>
using storage_for = std::aligned_storage<sizeof(T), alignof(T)>;
  
// -----------------------------------------------------------------------------

} // end namespace
#endif
#ifndef NASH_PRINT_STATE_HPP
#define NASH_PRINT_STATE_HPP

#include <ostream>
#include <utility>

namespace natch {

template<class T>
void print_state (std::ostream& out, T const& value)
{
  static std::hash<T> hasher;
  out             << "$HASH$" << hasher (value);
}

} // end namespace

#endif
#ifndef STATIC_TESTER_HPP
#define STATIC_TESTER_HPP


#include <functional>
#include <type_traits>
#include <iostream>
#include <vector>

#define NATCH_CREATE_CHECK(trait_name, test_spec, error_msg_str) \
template<class T1> \
struct trait_name { \
  typedef typename std::decay<typename std::remove_pointer<T1>::type>::type T; \
  template<class U> \
  static void is_lvalue (U&); \
  template<class U, class = typename std::enable_if<std::is_same<typename std::decay<U>::type, U>::value>::type> \
  static void is_rvalue (U&&); \
  static void implicit_conversion (T const&); \
  template<class U, class = T> static U & val (); \
  template<class U, class = T> static U const& const_val (); \
  template<class U, class = T> static natch::StrictConvertable<U,        true>       val_strict (); \
  template<class U, class = T> static natch::StrictConvertable<U const,  true> const_val_strict (); \
  template<class Target, class = decltype (test_spec)> \
  static std::true_type test (int); \
  template<class> static std::false_type test (...); \
  static constexpr bool value = decltype(test<T>(0))::value; \
  static constexpr char const * error_msg = error_msg_str; \
}

#define NATCH_CREATE_REVERSE_CHECK(trait_name, test_spec, error_msg_str) \
  NATCH_CREATE_CHECK(inverted_ ## trait_name, test_spec, error_msg_str); \
template<class T> \
struct trait_name : inverted_ ## trait_name<T> { \
  static constexpr bool value = !inverted_ ## trait_name <T>::value; \
}

namespace natch {

  template<class T, bool STRICT>
  struct StrictConvertable {
    typedef T type;

    StrictConvertable ()                         = delete;
    StrictConvertable (StrictConvertable const&) = delete;

    template<class A, class B>
    using enable_if_same = std::enable_if<
      std::is_same<
        typename std::decay<A>::type,
        typename std::decay<B>::type
      >::value || STRICT == false
    >;

    template<class U, class = typename enable_if_same<type, U>::type>
    operator U () const;

    T * operator->() const;
  };

namespace impl {
  template<
    template<class...> class success_handler,
    template<class...> class failure_handler,
    class target,
    class fails_wrapper,
    template<class> class... tests
  > struct ci;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  template<
    template<class...> class success_handler,
    template<class...> class failure_handler,
    class target
  >
  struct ci<success_handler, failure_handler, target, failure_handler<>>
  {
    typedef success_handler<target> type;
  };
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  template<
    template<class...> class success_handler,
    template<class...> class failure_handler,
    class target,
    class f1,
    class... fails
  >
  struct ci<success_handler, failure_handler, target, failure_handler<f1, fails...>>
  {
    typedef failure_handler<f1, fails...> type;
  };

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  template<
    template<class...> class success_handler,
    template<class...> class failure_handler,
    class target,
    class... fails,
    template<class> class test,
    template<class> class... tests
  >
  struct ci<success_handler, failure_handler, target, failure_handler<fails...>, test, tests...>
  {
    using type = typename std::conditional<test<target>::value,
      ci<success_handler, failure_handler, target, failure_handler<fails...              >, tests...>,
      ci<success_handler, failure_handler, target, failure_handler<fails..., test<target>>, tests...>
    >::type::type;
  };
}

template<
  template<class...> class success_handler,
  template<class...> class failure_handler,
  class target,
  template<class> class... tests
>
struct conditionally_instantiate
  : impl::ci<success_handler, failure_handler, target, failure_handler<>, tests...>
{ };

template<class... Errors>
struct static_fail_handler {
  template<class... Ts>
  static_fail_handler (Ts&&...) 
  { /* dummy */ }

  void run () {
    std::cout << "ERROR:FATAL ";

    for (auto const& err : std::vector<std::string> { Errors::error_msg... }) {
      std::cout << err << ";";
    }

    std::cout << "\n";
  }
};

}

#endif
#ifndef NATCH_UTILS_HPP
#define NATCH_UTILS_HPP


#include <functional>
#include <iterator>
#include <iostream>
#include <ostream>
#include <sstream>
#include <vector>
#include <string>
#include <cctype>


namespace natch {
  template<class T, class Destroyer>
  struct raii_wrapper {
    template<class U, class D>
    raii_wrapper (U&& data, D&& destroyer)
      : _value     (std::forward<U> (data))
      , _destroyer (std::forward<D> (destroyer))
    { }

    ~raii_wrapper () {
      _destroyer (_value);
    }

    T&       value ()       { return _value; }
    T const& value () const { return _value; }

    T             _value;
    Destroyer _destroyer;
  };

  template<class C, class D>
  auto make_raii (C&& create, D&& destroyer) -> raii_wrapper<decltype (std::forward<C> (create) ()), typename std::remove_reference<D>::type>
  {
    return { std::forward<C> (create) (), std::forward<D> (destroyer) };
  }

  template<class T, class F, class U, class... Us>
  auto for_each_type (F&& f, U&& arg, Us&&... args)
    -> typename std::enable_if<std::is_same<typename std::decay<T>::type, typename std::decay<U>::type>::value == false>::type;

  template<class T, class F, class U, class... Us>
  auto for_each_type (F&& f, U&& arg, Us&&... args)
    -> typename std::enable_if<std::is_same<typename std::decay<T>::type, typename std::decay<U>::type>::value ==  true>::type;

  template<class T, class F>
  void for_each_type (F&& f)
  { }

  template<class T, class F, class U, class... Us>
  auto for_each_type (F&& f, U&& arg, Us&&... args)
    -> typename std::enable_if<std::is_same<typename std::decay<T>::type, typename std::decay<U>::type>::value == false>::type 
  {
    for_each_type<T> (std::forward<F> (f), std::forward<Us> (args)...);
  }

  template<class T, class F, class U, class... Us>
  auto for_each_type (F&& f, U&& arg, Us&&... args)
    -> typename std::enable_if<std::is_same<typename std::decay<T>::type, typename std::decay<U>::type>::value ==  true>::type 
  {
    for_each_type<T> (std::forward<F> (f), std::forward<Us> (args)...);
    std::forward<F> (f) (std::forward<U> (arg));
  }

  struct FromStringConverter {
    FromStringConverter (std::string const& src) : _data (src) { }
    FromStringConverter (std::string&& src) : _data (std::move (src)) { }

    template<class T>
    operator T () {
      std::istringstream iss (_data);
      T ret;

      if (!(iss >> ret))
        throw natch::test_error ("FromStringConverter::operator T() failed to convert source data");

      return ret;
    }

    template<class T, class... Ts>
      operator std::vector<T, Ts...> () {
        std::istringstream iss (_data);
        std::vector<T, Ts...> ret;

        std::copy (
          std::istream_iterator<T> (iss),
          std::istream_iterator<T> (),
          std::back_inserter (ret)
        );

        return ret;
      }

    std::string _data;
  };

  template<class T>
  FromStringConverter lexically_convert (T&& val) {
    return FromStringConverter (std::forward<T> (val));
  }

  struct swallow {
    template<class... Us>
    swallow (Us&&...) { }
  };

  struct consume_whitespace_manip {
    friend std::istream& operator>> (std::istream& stream, consume_whitespace_manip) {

      while (stream && std::isspace (stream.peek ()))
        stream.ignore (1);

      return stream;
    }
  };
}

#endif
#ifndef NATCH_VARIABLE_HPP
#define NATCH_VARIABLE_HPP


#include <memory>
#include <stdexcept>

namespace natch {
  // -----------------------------------------------------------------------------

  template<class T, bool = std::is_default_constructible<T>::value>
  struct default_create {
    typedef T  value_type;
    typedef T*    pointer;

    template<class... Ts>
    void operator () (pointer addr, Ts&&... args) const {
      new (addr) value_type (std::forward<Ts> (args)...);
    }

    void operator () (pointer addr) const {
      new (addr) value_type ();
    }
  };

  template<class T>
  struct default_create<T, false> : default_create<T, true> {
    typedef T  value_type;
    typedef T*    pointer;

    [[noreturn]]
    void operator () (pointer addr) const {
      throw std::runtime_error ("T is not default-constructible!\n");
    }
  };

  // -----------------------------------------------------------------------------

  namespace details {
    template<class T, class Creator>
    class variable_t {
      private:
        typedef typename storage_for<T>::type storage_type;

      protected:
        typedef T             value_type;
        typedef T*               pointer;
        typedef T const *  const_pointer;
        typedef T&             reference;
        typedef T const& const_reference;

      protected:
        template<class T1 = void, class... Us>
        void construct (Us&&...);

        void destruct ();

        bool alive () const;

        pointer       addr ();
        const_pointer addr () const;


        ~variable_t ();

      private:
        storage_type _storage;
        bool         _living_storage = false; 
    };

    template<class T, class Creator>
    class variable_t<T*, Creator> {
      protected:
        typedef T             value_type;
        typedef T*               pointer;
        typedef T const *  const_pointer;
        typedef T&             reference;
        typedef T const& const_reference;

      protected:
        template<class T1 = T, class... Ts>
        void construct (Ts&&...);

        void destruct ();

        bool alive () const;

        pointer       addr ();
        const_pointer addr () const;

        ~variable_t ();

      private:
        std::unique_ptr<T> _ptr;
    };
  }

  template<class T, class Creator = default_create<T>>
  class variable : details::variable_t<T, Creator> {
    protected:
      typedef details::variable_t<T, Creator> _base;

    public:

      // gcc 4.8.1 workaround
      using value_type      = typename _base::value_type;
      using pointer         = typename _base::pointer;
      using const_pointer   = typename _base::const_pointer;
      using reference       = typename _base::reference;
      using const_reference = typename _base::const_reference;

      typedef std::string    name_type;

      using _base::construct;
      using _base::destruct;
      using _base::alive;
      using _base::addr;

      variable (name_type name);

      name_type const& name  () const;
      reference        value ();
      const_reference  value () const;

      reference operator*  ();
      pointer   operator-> ();

      const_reference operator*  () const;
      const_pointer   operator-> () const;

      explicit operator bool () const;

    private:
      name_type _name;
  };
}

// -------------------------- IMPLEMENTATION ----------------------------------

#include <iostream>

namespace natch { namespace details {

  template<class T, class Creator>
  template<class T1, class... Us>
  void
  variable_t<T, Creator>::construct (Us&&... args)
  {
    destruct ();
    new (addr ()) value_type (std::forward<Us> (args)...);
    _living_storage = true;
  }

  template<class T, class Creator>
  void
  variable_t<T, Creator>::destruct ()
  {
    if (alive ()) {
      addr ()->~value_type ();
      _living_storage = false;
    }
  }

  template<class T, class Creator>
  bool
  variable_t<T, Creator>::alive () const {
    return _living_storage;
  }

  template<class T, class Creator>
  typename variable_t<T, Creator>::pointer
  variable_t<T, Creator>::addr () {
    return reinterpret_cast<T*> (&_storage);
  }

  template<class T, class Creator>
  typename variable_t<T, Creator>::const_pointer
  variable_t<T, Creator>::addr () const {
    return reinterpret_cast<T const*> (&_storage);
  }

  template<class T, class Creator>
  variable_t<T, Creator>::~variable_t ()
  {
    destruct ();
  }

  // --------------------- POINTER SPECIALIZATION ------------------------------


  template<class T, class Creator>
  template<class T1, class... Ts>
  void
  variable_t<T*, Creator>::construct (Ts&&... args)
  {
    _ptr.reset (new T1 (std::forward<Ts> (args)...));
  }

  template<class T, class Creator>
  void
  variable_t<T*, Creator>::destruct () 
  {
    _ptr.reset ();
  }

  template<class T, class Creator>
  bool
  variable_t<T*, Creator>::alive () const
  {
    return _ptr != nullptr; 
  }

  template<class T, class Creator>
  typename variable_t<T*, Creator>::pointer
  variable_t<T*, Creator>::addr () {
    return _ptr.get ();
  }

  template<class T, class Creator>
  typename variable_t<T*, Creator>::const_pointer
  variable_t<T*, Creator>::addr () const {
    return _ptr.get ();
  }

  template<class T, class Creator>
  variable_t<T*, Creator>::~variable_t ()
  {
    destruct ();
  }

}}

namespace natch {

  template<class T, class C>
  variable<T, C>::variable (name_type name)
    : _base ()
    , _name {name}
  { }

  template<class T, class C>
  inline typename variable<T, C>::name_type const&
  variable<T, C>::name () const 
  {
    return _name;
  }

  template<class T, class C>
  inline typename variable<T, C>::reference
  variable<T, C>::value ()
  {
    if (alive ())
      return *addr ();

    throw std::runtime_error ("uninitialized data in variable<T,C>::value ()");
  }

  template<class T, class C>
  inline typename variable<T, C>::const_reference
  variable<T, C>::value () const
  {
    if (alive ())
      return *addr ();

    throw std::runtime_error ("uninitialized data in variable<T,C>::value () const");
  }

  template<class T, class C>
  inline typename variable<T, C>::reference
  variable<T, C>::operator* ()
  {
    if (alive ())
      return *addr ();

    throw std::runtime_error ("uninitialized data in variable<T,C>::operator* ()");
  }

  template<class T, class C>
  inline typename variable<T, C>::pointer
  variable<T, C>::operator-> () 
  {
    if (alive ())
      return addr ();

    throw std::runtime_error ("uninitialized data in variable<T, C>::operator-> ()");
  }

  template<class T, class C>
  inline typename variable<T, C>::const_reference
  variable<T, C>::operator* () const
  {
    if (alive ())
      return *addr ();

    throw std::runtime_error ("uninitialized data in variable<T,C>::operator* () const");
  }

  template<class T, class C>
  inline typename variable<T, C>::const_pointer
  variable<T, C>::operator-> () const
  {
    if (alive ())
      return addr ();

    throw std::runtime_error ("uninitialized data in variable<T,C>::operator-> () const");
  }

  template<class T, class C>
  inline variable<T, C>::operator bool () const
  {
    return alive ();
  }

  template<class T, class C>
  void print_state (std::ostream& out, variable<T, C> const& var)
  {
    out << var.name () << ": ";
    { 
      if (var.alive ()) print_state (out, var.value ());
      else              out << "<" "???" ">";
    }
    out << "; ";
  }

} // end namespace


#endif
#ifndef NATCH_VARIABLE_TRACER_HPP
#define NATCH_VARIABLE_TRACER_HPP

#include <memory>
#include <map>
#include <vector>
#include <sstream>
#include <iostream>
#include <iterator>
#include <algorithm>
#include <set>
#include <cstddef>


namespace natch {

class tracer {
  public:
    typedef std::string  command_type;
    typedef std::string   result_type;
    typedef std::string variable_name;

  void trace (command_type const& command);
  void trace (command_type const& command, result_type const& result);

  std::string          backtrace () const;
  std::string relevant_backtrace () const;
  std::string diagnostic (std::string const& ans1, std::string const& ans2) const;

  protected:
    std::vector<command_type> _commands;
};

inline void
tracer::trace (tracer::command_type const& command) 
{
  trace (command, "");
}

inline void
tracer::trace (tracer::command_type const& command, tracer::result_type const& result)
{
  _commands.push_back (command);
}

inline std::string
tracer::backtrace () const {
  std::ostringstream oss;

  for (std::size_t i = 0; i < _commands.size (); ++i)
    oss << (i+1) << ": " << _commands[i] << "\n";

  return oss.str ();
}

inline std::string 
tracer::relevant_backtrace () const 
{
  if (_commands.size () == 0)
    return ""; 

  auto get_variables = [](std::string const& data) {
    std::istringstream iss (data);

    std::set<variable_name> vars;

    std::copy_if (
      std::istream_iterator<variable_name> (iss),
      std::istream_iterator<variable_name> (),
      std::inserter (vars, vars.begin ()),
      [](variable_name const& x) {
        return x.size () && x[0] == '$';
      }
    );

    return vars;
  };

  auto vars = get_variables (_commands.back ());
  std::vector<std::string> relevant_cmds;

  if (vars.size ()) {
    for (auto rit = _commands.rbegin (); rit != _commands.rend (); ++rit) {
      auto current_vars = get_variables (*rit);

      for (auto const& var : current_vars) {
        if (vars.find (var) != vars.end ()) {
          vars.insert (current_vars.begin (), current_vars.end ());
          relevant_cmds.push_back (*rit);
          break;
        }
      }
    }
  } else {
    relevant_cmds.push_back (*_commands.rbegin ()); 
  }

  {
    std::ostringstream oss;

    std::size_t i = 1;
    for (auto rit = relevant_cmds.rbegin (); rit != relevant_cmds.rend (); ++rit, ++i) {
      oss << i << ": " << *rit << '\n';
    }

    return oss.str ();
  }
}

inline std::string
tracer::diagnostic (std::string const& ans1, std::string const& ans2) const
{
  auto read_token = [] (std::istream& iss, std::string& dst, char delimiter) {
    std::string token;

    if (!(iss >> natch::consume_whitespace_manip {}))
      return false;

    while (true) {
      std::string buffer;

      if (!std::getline (iss, buffer, delimiter)) {
        return false;
      }

      if (buffer.empty ())
        break;

      token += buffer;

      if (token.back () != '\\')
        break;

      if (token.size () >= 2 && *(token.rbegin ()+1) == '\\')
        break;
      else
        token += delimiter;
    }

    dst = token;
    return true;
  };

  auto unescape_token = [] (std::string& data) {
    std::string::size_type needle_pos = 0;

    if (data.empty ())
      return;

    while ((needle_pos = data.find ('\\', needle_pos)) != std::string::npos) {
      if ((needle_pos+1) < data.size () && data[needle_pos+1] != 'n')
        data.erase (needle_pos, 1); 

      needle_pos += 1;
    }
  };

  auto build_map = [&read_token, &unescape_token](std::string const& data) {
    std::istringstream iss (data);
    std::string key, value;

    std::map<std::string, std::string> table;

    while (true) {
      if (read_token (iss, key, ':') == false)
        break;

      if (read_token (iss, value, ';') == false)
        throw natch::logic_error ("Unexpected output-data, aborting! ");

      unescape_token   (key);
      unescape_token (value);

      for (int i = 0; table.insert ({key, value}).second == false; ++i) {
        key += "_" + std::to_string (i);
      }
    }

    return table;
  };

  auto r1 = build_map (ans1);
  auto r2 = build_map (ans2);

  std::vector<decltype(r1)::value_type> intermediate_diff;

  std::set_symmetric_difference (
    r1.begin (), r1.end (),
    r2.begin (), r2.end (),
    std::back_inserter (intermediate_diff)
  );

  std::map<std::string, std::pair<std::string, std::string>> diff;

  for (auto const& e : intermediate_diff) {
    if (r1[e.first].find ("$HASH$") == 0)
      continue;

    diff[e.first] = { r1[e.first], r2[e.first] };
  }

  std::ostringstream oss;

  for (auto const& d : diff) {
    auto const print = [](std::ostream& stream, std::string const& data) -> std::ostream& {
      if (data.size ()) return stream << '\'' << data << '\'';
      else              return stream << "None";
    };

    oss << d.first   << " => "; print (oss, d.second.second); oss <<  " ";
    oss << "should have been "; print (oss, d.second.first);  oss << "\n";
  }

  return oss.str ();
}


} // end namespace

#endif 
#ifndef NATCH_BASIC_ENVIRONMENT_HPP
#define NATCH_BASIC_ENVIRONMENT_HPP

#include <iostream>
#include <cstdlib>
#include <functional>
#include <string>


namespace natch {

class basic_environment {
  public:
    enum class Mode {
      Active, // execute everything sent to .invoke
      Idle    //  ignore everything sent to .invoke
    };

    basic_environment ();
    basic_environment (std::istream& input_stream, std::ostream& output_stream);

    std::ostream& output_stream ();
    std::istream&  input_stream ();

    void set_output_stream (std::ostream& output_stream);
    void set_input_stream  (std::istream& input_stream);

    void set_execution_enabled (bool);
    void set_execution_mode (Mode);

    Mode get_execution_mode () const;

    template<class F, class... Ts>
    void invoke (F&&, Ts&&...);

    template<class Key, class Value>
    void output (Key&&, Value&&);

    template<class Key, class... Ts>
    void output (Key&&, Ts&&...);

    [[noreturn]]
    void fatal_error (std::string const&, int exit_code = 0);
    void logic_error (std::string const&);
    void  test_error (std::string const&);

    void print_info  (std::string const&);

  protected:
    void print_error (std::string const&, std::string const&);

    std::istream*  _input_stream;
    std::ostream* _output_stream;
    Mode           _mode;
};

// -------------------------- IMPLEMENTATION ----------------------------------

basic_environment::basic_environment ()
  : basic_environment (std::cin, std::cout)
{ }

basic_environment::basic_environment (std::istream& input, std::ostream& output)
  :  _input_stream (&input)
  , _output_stream (&output)
  , _mode (Mode::Active)
{ }


inline void
basic_environment::set_execution_enabled (bool flag)
{
  if (flag) set_execution_mode (Mode::Active);
  else      set_execution_mode (Mode::Idle);
}

inline void
basic_environment::set_execution_mode (basic_environment::Mode m)
{
  _mode = m;
}

inline basic_environment::Mode
basic_environment::get_execution_mode () const 
{
  return _mode;
}

template<class F, class... Ts>
inline void
basic_environment::invoke  (F&& func, Ts&&... args)
{
  if (_mode == Mode::Idle)
    return;

  func (std::forward<Ts> (args)...);
}

inline std::ostream& 
basic_environment::output_stream () 
{
  return *_output_stream;
}

inline std::istream&
basic_environment::input_stream ()
{
  return *_input_stream;
}

inline void
basic_environment::set_output_stream (std::ostream& output_stream) 
{
  _output_stream = &output_stream;
}

inline void
basic_environment::set_input_stream (std::istream& input_stream) 
{
  _input_stream = &input_stream;
}

template<class Key, class Value>
inline void
basic_environment::output (Key&& key, Value&& value)
{
  output_stream ()
    << std::forward<Key> (key) << ": "
    << std::boolalpha << std::forward<Value> (value) << std::noboolalpha
    << "; "; 
}

template<class Key, class... Ts>
inline void
basic_environment::output (Key&& key, Ts&&... values) {
  natch::swallow { 
    (output_stream () << std::forward<Key> (key) << ": "),
    (output_stream () << std::forward<Ts> (values))...,
    (output_stream () << "; ")
  };
}

void inline
basic_environment::fatal_error (std::string const& msg, int exit_code)
{
  print_error ("FATAL", msg);

  std::exit (exit_code);
}

void inline
basic_environment::logic_error (std::string const& msg)
{
  print_error ("LOGIC", msg);
}

void inline 
basic_environment::test_error (std::string const& msg)
{
  print_error ("TEST", msg);
}

void inline
basic_environment::print_info (std::string const& msg)
{
  output_stream () << "INFO: " << msg << '\n'; 
}

void inline
basic_environment::print_error (std::string const& type, std::string const& msg)
{
  output_stream () << "ERROR:" << type << " " << msg << '\n';
}


} // end namespace

#endif
#ifndef NATCH_DYNAMIC_MEMORY_TRACER_HPP
#define NATCH_DYNAMIC_MEMORY_TRACER_HPP


#include <cstdlib>
#include <new>
#include <map>
#include <iostream>
#include <cstddef>
#include <cstring>

namespace natch {

class memory_tracer {
  public:
    typedef std::size_t   id_type;
    typedef std::size_t size_type;
    typedef long long   diff_type;
    typedef void *        pointer;

    class meminfo {
      friend class memory_tracer;

      public:
        typedef memory_tracer::size_type     size_type;
        typedef memory_tracer::diff_type     diff_type;
        typedef memory_tracer::id_type       id_type;
        typedef void *                       pointer;
        typedef std::map<pointer, size_type> memory_map;

        meminfo (id_type);
        meminfo (meminfo const&) = default;
        meminfo (meminfo&&)      = default;

        size_type memory_usage () const;

        void trace   (pointer, size_type);
        void untrace (pointer);

        memory_map const& get_memory_map () const;

        void lock ();
        void unlock ();

        id_type id () const;

        bool operator< (meminfo const& rhs) const;

      protected:

      private:
        size_type const              _id;
        std::map<pointer, size_type> _memory_map;
        size_type                    _memory_usage;
        bool                         _is_active;
    };

    pointer allocate (size_type count);
    void    deallocate (pointer p);

    static meminfo& create_meminfo ();
    static memory_tracer& get ();

  protected:
    memory_tracer ()                     = default;
    memory_tracer (memory_tracer const&) = delete;
    memory_tracer (memory_tracer&&)      = delete;

    ~memory_tracer ();

    void signal_trace   (pointer, size_type);
    void signal_untrace (pointer);

  private:
    std::map<id_type,   meminfo> _handles;
    volatile bool                _trace_allocs = true;
};

} // end namespace

void* operator new   (std::size_t count);
void* operator new[] (std::size_t count);
void* operator new   (std::size_t count, std::nothrow_t const&) noexcept (true);
void* operator new[] (std::size_t count, std::nothrow_t const&) noexcept (true);

void operator delete   (void * ptr) noexcept (true);
void operator delete[] (void * ptr) noexcept (true);
void operator delete   (void * ptr, std::nothrow_t const&) noexcept (true);
void operator delete[] (void * ptr, std::nothrow_t const&) noexcept (true);

// -------------------------- IMPLEMENTATION ----------------------------------

namespace natch {

memory_tracer::meminfo::meminfo (memory_tracer::meminfo::id_type id)
  : _id (id)
  , _memory_usage (0)
  , _is_active (true)
{ }

memory_tracer::meminfo::size_type
memory_tracer::meminfo::memory_usage () const
{
  return _memory_usage;
}

void
memory_tracer::meminfo::trace (memory_tracer::meminfo::pointer p, memory_tracer::meminfo::size_type size)
{
  if (_is_active == true) {
    _is_active = false;
    {
      _memory_map.insert ({p, size});  
      _memory_usage += size;
    }
    _is_active = true;
  }
}

void
memory_tracer::meminfo::untrace (memory_tracer::meminfo::pointer p)
{
  if (_is_active == true) {
    auto it = _memory_map.find (p);

    if (it != _memory_map.end ()) {
      _memory_usage -= it->second;
      _memory_map.erase (it);
    }
  }
}

memory_tracer::meminfo::memory_map const&
memory_tracer::meminfo::get_memory_map () const {
  return _memory_map;
}

void
memory_tracer::meminfo::lock ()
{
  _is_active = true;
}

void
memory_tracer::meminfo::unlock ()
{
  _is_active = false;
}

memory_tracer::id_type
memory_tracer::meminfo::id () const 
{
  return _id;
}

void
memory_tracer::signal_trace (memory_tracer::pointer p, memory_tracer::size_type size)
{
  for (auto& info : _handles)
    info.second.trace (p, size);
}

void
memory_tracer::signal_untrace (memory_tracer::pointer p)
{
  for (auto& info : _handles)
    info.second.untrace (p);
}

bool
memory_tracer::meminfo::operator< (memory_tracer::meminfo const& rhs) const
{
  return _id < rhs._id;
}

memory_tracer::~memory_tracer ()
{
  _trace_allocs = false;
}

memory_tracer&
memory_tracer::get ()
{
  static memory_tracer _mt; return _mt;
}

memory_tracer::meminfo&
memory_tracer::create_meminfo ()
{

  auto&     m = memory_tracer::get ();
  meminfo val = (
    m._handles.size () ? m._handles.rbegin ()->second.id () + 1 : 1
  );

  return m._handles.emplace (
    std::make_pair (val.id (), val)
  ).first->second;
}

memory_tracer::pointer
memory_tracer::allocate (memory_tracer::size_type count)
{
  pointer p = std::malloc (count);

  if (p) {
    std::memset (p, 0xFF, count);

    if (_trace_allocs) {
      _trace_allocs = false;

      signal_trace (p, count);

      _trace_allocs = true;
    }
  }

  return p;
}

void
memory_tracer::deallocate (memory_tracer::pointer p)
{
  if (_trace_allocs) {
    _trace_allocs = false;

    signal_untrace (p);

    _trace_allocs = true;
  }

  std::free (p);
}

} // end namespace

void*
operator new (std::size_t count)
{
  void * p = operator new (count, std::nothrow_t {});

  if (p == nullptr)
    throw std::bad_alloc ();

  return p;
}

void*
operator new[] (std::size_t count)
{
  return operator new (count);  
}

void*
operator new (std::size_t count, std::nothrow_t const& tag)
  noexcept (true)
{
  return natch::memory_tracer::get ().allocate (count);
}

void*
operator new[] (std::size_t count, std::nothrow_t const& tag)
  noexcept (true)
{
  return operator new (count, tag);
}

void
operator delete (void * p)
  noexcept (true)
{
  natch::memory_tracer::get ().deallocate (p);
}

void
operator delete[] (void * p)
  noexcept (true)
{
  operator delete (p);
}

void
operator delete (void * p, std::nothrow_t const& tag)
  noexcept (true)
{
  operator delete (p);
}

void
operator delete[] (void * p, std::nothrow_t const& tag)
  noexcept (true)
{
  operator delete[] (p);
}

#endif
#ifndef NATCH_INSTRUCTION_HPP
#define NATCH_INSTRUCTION_HPP


#include <memory>
#include <type_traits>
#include <iomanip>
#include <iostream>
#include <limits>
#include <functional>
#include <tuple>

namespace natch {

class instruction {
  public:
    template<class E, class F>
    instruction (E& env, F&&);

    void handle ();

  protected:
    class instruction_wrapper {
      public:
        virtual void handle () = 0;
    };

    template<class E, class F>
    class instruction_handler_t : public instruction_wrapper {
      public:
        typedef function_info<F> handler_info;
        typedef F                handler_type;
        typedef E            environment_type;

        template<class U>
        instruction_handler_t (E& env, U&& f);

        void handle () final;

        template<class T, class... Ts, class... Us>
        void invoke (type_list<T, Ts...>, Us&&...);

        template<class... Xs, class... Ts, class... Us>
        void invoke (type_list<std::vector<Xs...>, Ts...>, Us&&...);


        template<class... Ts, class... Us, class Env = environment_type>
        void invoke (type_list<typename Env::variable_type, Ts...>, Us&&...);

        template<class... Ts, class... Us, class Env = environment_type>
        void invoke (type_list<typename identity<Env>::type, Ts...>, Us&&...);

        template<class... Us>
        void invoke (type_list<>, Us&&...);


      private:
        handler_type      _impl;
        environment_type& _env;
    };

  private:
    std::unique_ptr<instruction_wrapper> _impl;
};

// -------------------------- IMPLEMENTATION ----------------------------------

template<class E, class F>
instruction::instruction (E& env, F&& f)
  : _impl { new instruction_handler_t<E, F> (env, std::forward<F> (f)) }
{ }

inline void
instruction::handle ()
{
  _impl->handle ();
}

// -----------------------------------------------------------------------------

template<class E, class F>
template<class U>
instruction::instruction_handler_t<E, F>::instruction_handler_t (E& env, U&& f)
  : _impl (std::forward<U> (f))
  , _env  (env)
{ }

template<class E, class F>
inline void
instruction::instruction_handler_t<E, F>::handle ()
{
  invoke (typename handler_info::decayed_argument_list {});
}

template<class E, class F>
template<class T, class... Ts, class... Us>
inline void
instruction::instruction_handler_t<E, F>::invoke (type_list<T, Ts...>, Us&&... args)
{
  typename std::decay<T>::type arg;

  if (!(_env.input_stream () >> arg)) {
    throw natch::test_error ("unable to read parameter string into expected type");
  }

  invoke (
    type_list<Ts...> {},
    std::forward<Us> (args)...,
    std::move (arg)
  );
}

template<class E, class F>
template<class... Xs, class... Ts, class... Us>
inline void
instruction::instruction_handler_t<E, F>::invoke (type_list<std::vector<Xs...>, Ts...>, Us&&... args)
{
  std::string rest;

  if (!(std::getline (_env.input_stream (), rest))) {
    throw natch::test_error ("unable to read parameter string into std::vector");
  }

  _env.input_stream ().putback ('\n');

  std::vector<Xs...> arg = natch::lexically_convert (std::move (rest));

  invoke (
    type_list<Ts...> {},
    std::forward<Us> (args)...,
    std::move (arg)
  );
}

template<class E, class F>
template<class... Ts, class... Us, class Env>
inline void
instruction::instruction_handler_t<E, F>::invoke (type_list<typename Env::variable_type, Ts...>, Us&&... args)
{
  typename environment_type::key_type var;

  if (!(_env.input_stream () >> var) || var[0] != '$') {
    throw natch::test_error ("invalid variable name: '" + var + "', aborting!");
  }

  invoke (
    type_list<Ts...> {},
    std::forward<Us> (args)...,
    _env.access (var)
  );
}

template<class E, class F>
template<class... Ts, class... Us, class Env>
inline void
instruction::instruction_handler_t<E, F>::invoke (type_list<typename identity<Env>::type, Ts...>, Us&&... args)
{
  invoke (
    type_list<Ts...> {},
    std::forward<Us> (args)...,
    _env
  );
}

template<class E, class F>
template<class... Us>
inline void
instruction::instruction_handler_t<E, F>::invoke (type_list<>, Us&&... args)
{
  std::string rest;

  if (!std::getline (_env.input_stream (), rest, '\n')) {
    throw natch::test_error ("parse error, aborting!");
  }

  if (rest.find_first_not_of (" \t\r\n") != std::string::npos) {
    throw natch::test_error ("trailing characters after command, aborting!");
  }

  _env.invoke (_impl, std::forward<Us> (args)...);
}

} // end namespace

#endif
#ifndef NATCH_INTERPRETER_HPP
#define NATCH_INTERPRETER_HPP


#include <unordered_map>
#include <istream>

namespace natch {

// -----------------------------------------------------------------------------

template<class Environment = basic_environment>
class interpreter {
  public:
    typedef std::string instruction_key_type;
    typedef Environment environment_type;

    interpreter () = default;
    interpreter (environment_type env);

    template<class F>
    void register_instruction (instruction_key_type const&, F&&);

    template<class F>
    void RI (instruction_key_type const&, F&&);

    environment_type& environment ();

    bool next ();
    void run  ();

  protected:
    std::unordered_map<instruction_key_type, instruction> _lookup;
    environment_type _env;
};

// -------------------------- IMPLEMENTATION ----------------------------------

template<class Environment>
interpreter<Environment>::interpreter (typename interpreter<Environment>::environment_type env)
  : _env (std::move (env))
{ }

template<class Environment>
template<class F>
inline void
interpreter<Environment>::register_instruction (instruction_key_type const& key, F&& f)
{
  auto res = _lookup.emplace (
    std::piecewise_construct,
    std::forward_as_tuple (key),
    std::forward_as_tuple (_env, std::forward<F> (f))
  );

  if (res.second == false) {
    res.first->second = natch::instruction (_env, std::forward<F> (f));
  }
}

template<class Environment>
template<class F>
inline void
interpreter<Environment>::RI (instruction_key_type const& key, F&& f)
{
  register_instruction (key, std::forward<F> (f));
}

template<class Environment>
inline typename interpreter<Environment>::environment_type&
interpreter<Environment>::environment () 
{
  return _env;
}

template<class Environment>
inline bool
interpreter<Environment>::next ()
{
  instruction_key_type name;

  if (!(_env.input_stream () >> name)) {
    return false; 
  }
  
  {
    auto it = _lookup.find (name);

    if (it == _lookup.end ())
      throw natch::test_error ("'" + name + "' is not a valid instruction, aborting!");

    it->second.handle ();
  }

  return true; 
}

template<class Environment>
inline void
interpreter<Environment>::run ()
{
  while (next ())
    ;
}

} // end namespace

#endif
#ifndef NATCH_JUDGE_HPP
#define NATCH_JUDGE_HPP


#include <iostream>
#include <fstream>

namespace natch {

class judge {
  public:
    judge (
      std::istream& ins_stream,
      std::istream& ans_stream,
      std::istream& usr_stream,
      std::string feedback_dir
    );

    void enable_author_messages (bool flag);
    void enable_score_file      (bool flag);

    [[noreturn]]
    void run ();
    
  protected:
    static constexpr char const *  judge_file = "judgemessage.txt";
    static constexpr char const *  score_file = "score.txt";
    static constexpr char const * author_file = "teammessage.txt";
    static constexpr char const *  error_file = "judgeerror.txt";

    enum RetCode {
      TEST_ACCEPTED = 42, TEST_REJECTED = 43, JUDGE_ERROR = 1
    };

    [[noreturn]]
    void emit (RetCode result);

    [[noreturn]]
    void handle_error (std::string const&, std::string const&, std::string const&);

    bool interpret (std::string const&, std::string, std::string);

  private:
    std::istream& _ins_stream;
    std::istream& _ans_stream;
    std::istream& _usr_stream;

    std::string   _feedback_directory;

    std::ofstream _judge_stream;
    std::ofstream _score_stream;
    std::ofstream _author_stream;
    std::ofstream _error_stream;

    natch::tracer _tracer;
};

// -------------------------- IMPLEMENTATION ----------------------------------

judge::judge (std::istream& ins, std::istream& ans, std::istream& usr, std::string feedback)
  : _ins_stream         (ins)
  , _ans_stream         (ans)
  , _usr_stream         (usr)
  , _feedback_directory (feedback)
  , _judge_stream       (feedback + "/" + judge_file)
  , _score_stream       ()
  , _author_stream      ()
  , _error_stream       (feedback + "/" + error_file)
{ }

inline void
judge::enable_author_messages (bool flag)
{
  if (flag) _author_stream.open  (_feedback_directory + "/" + author_file);
  else      _author_stream.close ();
}

inline void
judge::enable_score_file (bool flag)
{
  if (flag) _score_stream.open  (_feedback_directory + "/" + score_file);
  else      _score_stream.close ();
}

void
judge::handle_error (std::string const& ins, std::string const& ans, std::string const& usr)
{

  std::istringstream iss_error (usr);

  std::vector<std::string> diagnostics;
  std::string error_type;
  std::string tmp;

  iss_error >> error_type;

  while (iss_error.peek () == ' ')
    iss_error.ignore ();

  while (std::getline (iss_error, tmp, ';')) {
    diagnostics.push_back (tmp);  
  }

  // ------------------------------------------------------------------------------------

  auto print_errors = [&] (std::ostream& out, bool include_backtrace) {
    std::string prefix = " * ";

    if (include_backtrace) {
      out << _tracer.backtrace () << "\n";
      prefix = " ^ error: ";
    }

    for (auto const& msg : diagnostics)
      out << prefix << msg << "\n";

    out.flush ();
  };


  // ------------------------------------------------------------------------------------

  if (error_type == "ERROR:FATAL") {
    print_errors (_author_stream, false);
    print_errors (_judge_stream,  false);

    emit (TEST_REJECTED);

  } else if (error_type == "ERROR:LOGIC") {
    if (ins.size () != 0)
      _tracer.trace (ins);

    print_errors (_author_stream, true);
    print_errors (_judge_stream,  true);

    emit (TEST_REJECTED);

  } else if (error_type == "ERROR:TEST") {
    throw natch::test_error (usr);

  } else {
    throw natch::test_error (usr);
  }
}

void
judge::run ()
{
  std::string ins_line;
  std::string ans_line;
  std::string usr_line;

  try {
    while (true) {
      std::getline (_usr_stream, usr_line);

      // error?

      if (usr_line.find ("ERROR:") == 0) {
        std::getline (_ins_stream, ins_line);
        std::getline (_ans_stream, ans_line);

        handle_error (ins_line, ans_line, usr_line);
      }

      if (usr_line.find ("INFO") == 0) {
        if (!std::getline (_ans_stream, ans_line) && ans_line.find ("INFO") == std::string::npos)
          throw natch::test_error ("mismatched INFO-line");

        _author_stream << usr_line << std::endl;
        _judge_stream  << usr_line << std::endl;

        continue;
      }

      // end of _ins_stream? test approved.
      {
        while (std::getline (_ins_stream, ins_line) && ins_line.find ('#') == 0)
          /* ignore comments */;

        if (_ins_stream.fail ())
          break;
      }


      // unexpected end of _ans_stream?

      if (!std::getline (_ans_stream, ans_line))
        throw natch::test_error ("_ans_stream is shorter than _ins_stream");

      // interpret data

      if (interpret (ins_line, ans_line, usr_line) == false)
        break;

    }

  } catch (natch::test_error const& e) {
    _error_stream  << "exception: " << e.what () << std::endl;
    _author_stream << "Unexpected error detected, please contact <froseen@kth.se>!" << std::endl;
    _author_stream << e.what () << std::endl;

    emit (JUDGE_ERROR);

  } catch (natch::logic_error const& e) {
    _error_stream << "Diagnostic: " << e.what () << std::endl;
    _author_stream << "Diagnostic: " << e.what () << std::endl;

    emit (TEST_REJECTED);
  }

  
  emit (TEST_ACCEPTED);
}

void
judge::emit (judge::RetCode result) 
{
  std::exit (result);
}

bool
judge::interpret (std::string const& ins, std::string ans, std::string usr_ans)
{
  if (ins.size () == 0)
    return true;

  if (usr_ans.compare (0, 6, "DATA: ") == 0 || ans.compare (0, 6, "DATA: ") == 0) {
    ans    .erase (0, 6); // remove "DATA: "
    usr_ans.erase (0, 6); // remove "DATA: "

    _tracer.trace (ins, usr_ans);
  }

  if (usr_ans != ans) {
    std::string const&   bs = _tracer.relevant_backtrace ();
    std::string const& diag = _tracer.diagnostic (ans, usr_ans);

    _author_stream << bs << std::endl;
    _judge_stream  << bs << std::endl;

    _author_stream << "  ^ error detected while evaluating the above" << std::endl;
    _judge_stream  << "  ^ error detected while evaluating the above" << std::endl;

    if (diag.size ()) {
      _author_stream << "\n" << diag << std::endl;
      _judge_stream  << "\n" << diag << std::endl;
    }
    
    emit (TEST_REJECTED);
  }

  return true;
}

}

#endif
#ifndef NATCH_STREAM_HELPERS_HPP
#define NATCH_STREAM_HELPERS_HPP

#include <ostream>
#include <sstream>

#include <cstdio>
#include <cstdlib>
#include <unistd.h>


namespace natch {
  struct ostream_redirect {
    ostream_redirect (std::ostream& a, std::ostream& b)
      : _a (a), _b (b), _orig_streambuf (_a.rdbuf (_b.rdbuf ()))
    { }

    ostream_redirect (ostream_redirect&& src)
      : _a (src._a)
      , _b (src._b)
      , _orig_streambuf (src._orig_streambuf)
    {
      src._orig_streambuf = nullptr;
    }

    ~ostream_redirect () {
      if (_orig_streambuf)
        _a.rdbuf (_orig_streambuf); 
    }

    std::ostream& _a;
    std::ostream& _b;
    std::streambuf * _orig_streambuf;
  };

  struct stdstream_redirect {
    stdstream_redirect (decltype (stdout), std::ostream&) { }
  };

  ostream_redirect
  make_ostream_redirect (std::ostream& a, std::ostream& b) {
    return ostream_redirect { a, b };
  }

  template<class F, class... Ts>
  std::string
  capture_stream (std::ostream& target, F&& callback, Ts&&... args) {
    auto oss        = std::ostringstream {};
    auto redirector = make_ostream_redirect (target, oss);

    callback (std::forward<Ts> (args)...);

    return oss.str ();
  }
  template<class F, class... Ts>
  std::string
  capture_output_of (FILE* stream, F&& callback, Ts&&... args)
  {
    auto stream_handler = make_raii (
      [&] {
        std::fflush (stream);
       
        int old_fd = dup (fileno (stream));
        if (old_fd == -1)
          throw "unable to dup file-descriptor in capture_output_of";

        return old_fd;
      },

      [&] (int old_fd) {
        dup2  (old_fd, fileno (stream));
        close (old_fd);

        std::clearerr (stream);
      }
    );

    auto file_handler = make_raii (
      [] {
        char filename[] = "natch.XXXXXX";
        int  file_fd;

        if ((file_fd = mkstemp (filename)) == -1)
          throw "unable to create temporary file";

        close (file_fd);

        return std::string { filename };
      },

      [] (std::string file) {
        unlink (file.c_str ());
      }
    );

    if (std::freopen (file_handler.value ().c_str (), "w", stream) == nullptr)
      throw natch::test_error ("std::freopen failed in capture_output_of");

    std::forward<F> (callback) (std::forward<Ts> (args)...); 

    std::fflush (stream);

    return static_cast<std::ostringstream&> (
      std::ostringstream {} << std::ifstream (file_handler.value ().c_str ()).rdbuf ()
    ).str (); 
  }
}

#endif
#ifndef NATCH_ENVIRONMENT_HPP
#define NATCH_ENVIRONMENT_HPP


#include <unordered_map>
#include <string>
#include <iostream>
#include <memory>
#include <functional>
#include <mutex>
#include <sstream>
#include <exception>

namespace natch {

template<class T = details::dummy_variable>
class environment : public basic_environment {
  public:
    typedef std::string                key_type;
    typedef T                        value_type;
    typedef variable<T>           variable_type;
    typedef memory_tracer::meminfo meminfo_type;

    typedef std::unordered_map<key_type, variable<T>> container_type;

    typedef typename container_type::iterator             iterator;
    typedef typename container_type::const_iterator const_iterator;

     environment (std::istream& input_stream, std::ostream& output_stream);
     environment (basic_environment const&);

     environment (environment const&) = default;
     environment (environment     &&) = default;

    ~environment ();

    template<class F, class... Ts>
    void invoke (F&&, Ts&&... args);

    variable_type& access (key_type const& key);
    void           erase  (key_type const& key);

    iterator begin ();
    iterator   end ();

    const_iterator begin () const;
    const_iterator   end () const;

  private:
    container_type _variables;
    meminfo_type&  _meminfo;
    std::size_t    _invocation_counter = 0;
};

// -------------------------- IMPLEMENTATION ----------------------------------

template<class T>
environment<T>::environment (std::istream& input, std::ostream& output)
  : basic_environment (input, output)
  , _meminfo (memory_tracer::create_meminfo ())
{
  _meminfo.unlock ();
}

template<class T>
environment<T>::environment (basic_environment const& src)
  : basic_environment (src)
  , _meminfo (memory_tracer::create_meminfo ())
{
  _meminfo.unlock ();
}

template<class T>
environment<T>::~environment ()
{
  {
    std::lock_guard<meminfo_type> _memlock (_meminfo);

    _variables.clear ();
  }

  if (_meminfo.get_memory_map ().size () != 0) {
    std::ostringstream oss;

    if (_meminfo.memory_usage ())
      oss << "leak of " << _meminfo.memory_usage () << " bytes detected, ";

    oss << _meminfo.get_memory_map ().size () << " allocation(s) did not have a corresponding deallocation.";

    if (std::uncaught_exception () == false)
      basic_environment::fatal_error (oss.str ());
  }
}

template<class T>
template<class F, class... Ts>
inline void
environment<T>::invoke (F&& func, Ts&&... args)
{
  if (_mode == Mode::Idle)
    return;

  auto variable_printer = [this] (variable_type const& var) {
    print_state (output_stream (), var);
  };

  auto escape_data = [] (std::string const& data) {
    std::string          escaped_data = data;
    std::string::size_type needle_pos = 0;

    while ((needle_pos = escaped_data.find_first_of ("\n:;\\", needle_pos)) != std::string::npos) {
      escaped_data.replace (
        needle_pos, 1,
        escaped_data[needle_pos] == '\n' ? "\\n" : (std::string {"\\"} + escaped_data[needle_pos])
      );

      needle_pos += 2;
    }

    return escaped_data;
  };

  // ----------------------------------------------------------------------- //
  // ----------------------------------------------------------------------- //

  {
    std::lock_guard<memory_tracer::meminfo> _memlock (_meminfo);
    std::ostringstream captured_output_stream;
    std::string student_stdout_data;

    {
      auto temporary_replace_output_stream = natch::make_raii (
        [&] {
          std::ostream * old_stream = &(output_stream ());
          set_output_stream (captured_output_stream);
          return old_stream;
        },
        [&] (std::ostream * old) { set_output_stream (*old); }
      );

      student_stdout_data = natch::capture_output_of (stdout,
        [&] (Ts&&... args) {
          func (std::forward<Ts> (args)...);

          for_each_type<variable_type> (
            variable_printer, std::forward<Ts> (args)...
          );
        },
        std::forward<Ts> (args)...  /* GCC BUG: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55914 */
      );
    }
    
    output_stream () << "DATA: " << captured_output_stream.str ();

    if (student_stdout_data.size ())
      output ("data printed on stdout", escape_data (student_stdout_data));

    output (escape_data ("natch::instruction_id"), ++_invocation_counter);

    output_stream () << std::endl;
  }
}

template<class T>
inline typename environment<T>::variable_type&
environment<T>::access (environment<T>::key_type const& key)
{
  auto it = _variables.find (key);

  if (it == _variables.end ()) {
    auto new_it = _variables.emplace (
      std::piecewise_construct,
      std::forward_as_tuple (key),
      std::forward_as_tuple (key)
    );

    return new_it.first->second;
  }

  return it->second;
}

template<class T>
inline void
environment<T>::erase (environment<T>::key_type const& key)
{
  _variables.erase (key);
}

template<class T>
inline typename environment<T>::iterator
environment<T>::begin () {
  return _variables.begin ();
}

template<class T>
inline typename environment<T>::iterator
environment<T>::end ()
{
  return _variables.end ();
}

template<class T>
inline typename environment<T>::const_iterator
environment<T>::begin () const
{
  return _variables.begin ();
}

template<class T>
inline typename environment<T>::const_iterator
environment<T>::end () const
{
  return _variables.end ();
}

} // end namespace

#endif
